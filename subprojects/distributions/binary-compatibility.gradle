/*
 * Copyright 2017 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



import japicmp.model.JApiChangeStatus
import me.champeau.gradle.japicmp.JapicmpTask
import org.gradle.api.attributes.Attribute
import org.gradle.binarycompatibility.rules.*
import org.gradle.binarycompatibility.transforms.*

buildscript {
    repositories {
        maven {
            url "https://plugins.gradle.org/m2/"
        }
    }
    dependencies {
        classpath 'me.champeau.gradle:japicmp-gradle-plugin:0.2.1'
    }
}

repositories {
    ivy {
        name 'Gradle distributions'
        url 'https://services.gradle.org'
        layout 'pattern', {
            ivy '[module]-ivy.xml'
            artifact '/distributions/[module]-[revision]-bin(.[ext])'
        }
    }
}

configurations {
    baseline
}

def ARTIFACT_TYPE = Attribute.of('artifactType', String)
Set publicProjects = pluginProjects + implementationPluginProjects + publicGroovyProjects - [project(':smokeTest'), project(':soak')]
def projects = publicProjects.collect { it.archivesBaseName - 'gradle-' }

dependencies {
    baseline "gradle:gradle:${releasedVersions.mostRecentFinalRelease}@zip"

    // This transform takes the Gradle zip distribution,
    // and unzips the Gradle jar files that it contains in a directory
    registerTransform {
        from.attribute(ARTIFACT_TYPE, 'zip')
        to.attribute(ARTIFACT_TYPE, 'gradle-libs-dir')
        artifactTransform(ExplodeZipAndFindJars)
    }

    projects.each { projectName ->
        // This transform uses the result of the exploded zip extraction
        // and returns a single jar file based on the lookup project name
        registerTransform {
            from.attribute(ARTIFACT_TYPE, 'gradle-libs-dir')
            to.attribute(ARTIFACT_TYPE, projectName)
            artifactTransform(FindGradleJar) {
                params(projectName)
            }
        }
    }
}

task checkBinaryCompatibility {}
check.dependsOn(checkBinaryCompatibility)

def acceptedViolations = loadBreakingChanges(project, releasedVersions.mostRecentFinalRelease)

projects.each { projectName ->
    def appendixName = projectName.split('-')*.capitalize().join('')
    def baselineConf = configurations.create("japicmp-baseline-${appendixName}") {
        extendsFrom configurations.baseline
        attributes.attribute(ARTIFACT_TYPE, projectName)
    }

    def t = task "japicmp${appendixName}"(type: JapicmpTask) {
        def jar = project(":${appendixName.uncapitalize()}").jar
        dependsOn jar
        inputs.file(project.file("src/changes/changes-since-${releasedVersions.mostRecentFinalRelease}.txt"))
        oldClasspath = baselineConf
        newClasspath = files(jar.archivePath)
        onlyModified = true
        failOnModification = false // we rely on the custom report to fail or not
        ignoreMissingClasses = true // each jar is tested independently, but may reference inexisting classes
        richReport {
            title = "Binary compatibility report for $projectName"
            destinationDir = file("$buildDir/reports/binary-compatibility")
            reportName = "${projectName}.html"
            addRule(AcceptedRegressionRule, acceptedViolations)
            addRule(JApiChangeStatus.NEW, IncubatingMissingRule)

            includedClasses = toPatterns(publicApiIncludes)
            excludedClasses = toPatterns(publicApiExcludes)
        }
    }
    checkBinaryCompatibility.dependsOn(t)
}

static List<String> toPatterns(List<String> packages) {
    def patterns = packages.collect {
        it.replaceAll('\\*\\*', '###')
            .replaceAll('/\\*', '/[A-Z][a-z_A-Z0-9]+')
            .replaceAll('/', '[.]')
            .replaceAll('###', '.*?')
    }
    patterns
}

static Map<String, String> loadBreakingChanges(Project p, String since) {
    def file = p.file("src/changes/changes-since-${since}.txt")
    def map = [:]
    if (file.exists()) {
        file.eachLine { line ->
            line = line.trim()
            if (line) {
                def (lookup, reason) = line.split(';')
                map[lookup] = reason
            }
        }
    }
    map
}

